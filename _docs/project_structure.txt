--- Folder Structure ---
.eslintignore
.eslintrc.cjs
.npmrc
.prettierignore
.prettierrc
[api]
    ├── [adapters]
        └── [database]
            ├── adapterInterfaces.ts
            ├── index.ts
            ├── [inMemory]
                ├── createItemAdapterInMemory.spec.ts
                ├── createItemAdapterInMemory.ts
                ├── createOrderAdapterInMemoryForAccountId.spec.ts
                └── createOrderAdapterInMemoryForAccountId.ts
            └── [jsonServer]
                ├── createItemAdapterJsonServer.spec.ts
                ├── createItemAdapterJsonServer.ts
                ├── createOrderAdapterJsonServer.spec.ts
                ├── createOrderAdapterJsonServer.ts
                └── myAxios.ts
    ├── [core]
        ├── [entities]
            ├── item.ts
            └── order.ts
        ├── [gateways]
            ├── gatewayInterfaces.ts
            ├── itemGateway.spec.ts
            ├── itemGateway.ts
            ├── orderGateway.spec.ts
            └── orderGateway.ts
        └── [usecases]
            ├── getAllAccounts.js
            ├── getAllOrdersForAccountId.spec.ts
            └── getAllOrdersForAccountId.ts
    ├── [server]
        ├── package.json
        ├── [src]
            └── index.ts
        └── tsconfig.json
    └── [utils]
        ├── add.test.ts
        ├── add.ts
        └── round.ts
[app]
    ├── app.vue
    ├── [assets]
        ├── [css]
            └── tailwind.css
    ├── [composables]
        ├── fetchOrders.spec.ts
        ├── fetchOrders.ts
        ├── getAccounts.js
        ├── getAccounts.test.js
        ├── selectDb.ts
        └── sharedState.ts
    ├── error.vue
    ├── index.html
    ├── [layouts]
        └── default.vue
    ├── [mvp]
    ├── [pages]
        ├── index.vue
        ├── Mini.vue
        └── teams.vue
nodemon.json
nuxt.config.ts
package.json
prettier.config.js
tailwind.config.js
tsconfig.json
vitest.config.ts

--- File Contents ---

--- File: .eslintignore ---


--- File: .eslintrc.cjs ---
module.exports = {
  env: {
    browser: true,
    es2021: true,
    'vitest-globals/env': true
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:vue/vue3-essential',
    '@vue/eslint-config-typescript',
    '@vue/eslint-config-prettier',
    'plugin:prettier/recommended',
    'plugin:vitest-globals/recommended'
  ],
  overrides: [
    {
      env: {
        node: true
      },
      files: ['.eslintrc.{js,cjs}'],
      parserOptions: {
        sourceType: 'script'
      }
    }
  ],
  parserOptions: {
    ecmaVersion: 'latest',
    parser: '@typescript-eslint/parser',
    sourceType: 'module',
    extraFileExtensions: ['.js']
  },
  plugins: ['@typescript-eslint', 'prettier', 'vue'],
  rules: {
    'vue/multi-word-component-names': 'off'
  }
}


--- File: .npmrc ---
shamefully-hoist=true

--- File: .prettierignore ---
# Ignore artifacts:
_docs
.nuxt
build
coverage
node_modules

# Ignore all HTML files:
**/*.html

--- File: .prettierrc ---
{
  "semi": false,
  "tabWidth": 2,
  "useTabs": false,
  "singleQuote": true,
  "printWidth": 100,
  "trailingComma": "none",
  "endOfLine": "lf",
  "vueIndentScriptAndStyle": true,
  "plugins": ["tailwindcss", "prettier-plugin-tailwindcss"]
}


--- File: api\adapters\database\adapterInterfaces.ts ---
import { ItemData } from 'entities/item'
import { OrderData } from 'entities/order'

export interface ItemAdapter {
  getById: (id: string) => Promise<ItemData | undefined>
  getByOrderId: (orderId: string) => Promise<ItemData[]>
  getByOrderIds: (orderIds: string[]) => Promise<ItemData[]>
}

export interface OrderAdapter {
  getAll: () => Promise<OrderData[]>
  getById: (orderId: string) => Promise<OrderData | undefined>
}


--- File: api\adapters\database\index.ts ---
import { config } from 'dotenv'

import { createItemAdapterInMemory } from './inMemory/createItemAdapterInMemory'
import { createOrderAdapterInMemoryForAccountId } from './inMemory/createOrderAdapterInMemoryForAccountId'
import { createItemAdapterJsonServer } from './jsonServer/createItemAdapterJsonServer'
import { createOrderAdapterJsonServer } from './jsonServer/createOrderAdapterJsonServer'

config() // load variables from .env into process.env

console.log(
  'Adapter Index: process.env.STORAGE_TYPE before',
  process.env.STORAGE_TYPE
)
if (!process.env.STORAGE_TYPE) {
  process.env.STORAGE_TYPE = 'InMemory'
}
console.log(
  'Adapter Index: process.env.STORAGE_TYPE after',
  process.env.STORAGE_TYPE
)

let createItemAdapter: any
let createOrderAdapter: any

switch (process.env.STORAGE_TYPE) {
  case 'inMemory':
    createItemAdapter = createItemAdapterInMemory
    createOrderAdapter = createOrderAdapterInMemoryForAccountId
    break
  case 'jsonServer':
    createItemAdapter = createItemAdapterJsonServer
    createOrderAdapter = createOrderAdapterJsonServer
    break
  default:
    throw new Error('Core → getAllOrdersForAccountId : Invalid storage type')
}

export { createItemAdapter, createOrderAdapter }


--- File: api\adapters\database\inMemory\createItemAdapterInMemory.spec.ts ---
import { itemDatas } from 'mock/inMemory'

import { createItemAdapterInMemory } from './createItemAdapterInMemory'

describe('createItemAdapterInMemory', () => {
  const adapter = createItemAdapterInMemory()
  describe('getById', () => {
    it('should return undefined when item id not found', async () => {
      const item = await adapter.getById('nonexistentId')
      expect(item).toBeUndefined()
    })

    it('should  return one item for existing item id', async () => {
      const item = await adapter.getById('item0')
      expect(item).toEqual(itemDatas[0])
    })
  })
  describe('getByOrderId', () => {
    it('should return an array of items for existing order id', async () => {
      const items = await adapter.getByOrderId('order0')
      expect(items).toEqual([itemDatas[0], itemDatas[1]])
    })

    it('should return an empty array for existing empty order', async () => {
      const items = await adapter.getByOrderId('order3')
      expect(items).toEqual([])
    })

    it('should return an empty array for non existing  order', async () => {
      const items = await adapter.getByOrderId('order99')
      expect(items).toEqual([])
    })
  })

  describe('getByOrderIds', () => {
    it('should return an array for array of existing orders', async () => {
      const items = await adapter.getByOrderIds(['order0', 'order1'])
      expect(items).toEqual(items.slice(0, 4))
    })

    it('should return an empty array for non existing orders', async () => {
      const items = await adapter.getByOrderId('order99')
      expect(items).toEqual([])
    })
  })
})


--- File: api\adapters\database\inMemory\createItemAdapterInMemory.ts ---
import { ItemData } from 'entities/item'
import { itemDatas } from 'mock/inMemory'

import { ItemAdapter } from '../adapterInterfaces'

export const createItemAdapterInMemory = (): ItemAdapter => {
  const items: ItemData[] = [...itemDatas]
  const getById = (itemId: string) =>
    Promise.resolve(items.find((item) => item.id === itemId))
  const getByOrderId = (orderId: string) =>
    Promise.resolve(items.filter((item) => item.orderId === orderId))
  const getByOrderIds = (orderIds: string[]) =>
    Promise.resolve(items.filter((item) => orderIds.includes(item.orderId)))
  return {
    getById,
    getByOrderId,
    getByOrderIds,
  }
}


--- File: api\adapters\database\inMemory\createOrderAdapterInMemoryForAccountId.spec.ts ---
import { orderDatas } from 'mock/inMemory'

import { createOrderAdapterInMemoryForAccountId } from './createOrderAdapterInMemoryForAccountId'

let adapter: any

describe('createOrderAdapterInMemoryForAccountId', () => {
  describe('for existing account', () => {
    beforeAll(() => {
      adapter = createOrderAdapterInMemoryForAccountId('account0')
    })
    describe('getById', () => {
      it('should return an order for exiting order id', async () => {
        const result = await adapter.getById('order0')
        expect(result).toEqual(orderDatas[0])
      })
      it('should return undefined for inexistant id', async () => {
        const result = await adapter.getById('inexistant')
        expect(result).toEqual(undefined)
      })
      it('should return undefined for order id from unrelated account', async () => {
        const result = await adapter.getById('order3')
        expect(result).toEqual(undefined)
      })
    })
    describe('getAll', () => {
      it('return all orders for this account', async () => {
        const result = await adapter.getAll()
        expect(result).toEqual(orderDatas.slice(0, 2))
      })
    })
  })
  describe('for a non existing account', () => {
    beforeAll(() => {
      adapter = createOrderAdapterInMemoryForAccountId('account99')
    })
    describe('getById', () => {
      it('should return undefined for exsiting order id', async () => {
        const result = await adapter.getById('order0')
        expect(result).toEqual(undefined)
      })
    })
    describe('getAll', () => {
      it('return empty array', async () => {
        const result = await adapter.getAll()
        expect(result).toEqual([])
      })
    })
  })
})


--- File: api\adapters\database\inMemory\createOrderAdapterInMemoryForAccountId.ts ---
import { OrderData } from 'entities/order'

import { inMemory } from '../../../../mock/inMemory'
import { OrderAdapter } from '../adapterInterfaces'

export const createOrderAdapterInMemoryForAccountId = (
  accountId: string
): OrderAdapter => {
  const orders: OrderData[] = [...inMemory.order]
  const getAll = (): Promise<OrderData[]> =>
    Promise.resolve(
      orders.filter(
        (order) =>
          order.clientId === accountId || order.supplierId === accountId
      )
    )
  const getById = async (orderId: string): Promise<OrderData | undefined> =>
    Promise.resolve((await getAll()).find((order) => order.id === orderId))
  return {
    getAll,
    getById,
  }
}


--- File: api\adapters\database\jsonServer\createItemAdapterJsonServer.spec.ts ---
import { inMemory } from 'mock/inMemory'

import { createItemAdapterJsonServer } from './createItemAdapterJsonServer'

describe('createItemAdapterJsonServer (real Axios)', () => {
  describe('getById', () => {
    it('should return itemData for item id', async () => {
      const itemAdapter = createItemAdapterJsonServer()
      const itemData = await itemAdapter.getById('item2')
      expect(itemData).toEqual(inMemory.item[2])
    })
    it('should return undefined for unknown item id', async () => {
      const itemAdapter = createItemAdapterJsonServer()
      const itemData = await itemAdapter.getById('unknown')
      expect(itemData).toBeUndefined()
    })
  })
  describe('getByOrderId', () => {
    it('should return itemDatas for order id', async () => {
      const itemAdapter = createItemAdapterJsonServer()
      const itemDatas = await itemAdapter.getByOrderId('order1')
      expect(itemDatas).toEqual([inMemory.item[2], inMemory.item[3]])
    })
    it('should return [] for unknown order id', async () => {
      const itemAdapter = createItemAdapterJsonServer()
      const itemDatas = await itemAdapter.getByOrderId('unknown')
      expect(itemDatas).toEqual([])
    })
  })
  describe('getByOrderIds', () => {
    it('should return itemDatas for order ids', async () => {
      const itemAdapter = createItemAdapterJsonServer()
      const itemDatas = await itemAdapter.getByOrderIds(['order1', 'order2'])
      expect(itemDatas).toEqual([
        inMemory.item[2],
        inMemory.item[3],
        inMemory.item[4],
        inMemory.item[5],
      ])
    })
    it('should return [] for unknown order ids', async () => {
      const itemAdapter = createItemAdapterJsonServer()
      const itemDatas = await itemAdapter.getByOrderIds(['unknown'])
      expect(itemDatas).toEqual([])
    })
  })
})


--- File: api\adapters\database\jsonServer\createItemAdapterJsonServer.ts ---
// src/adapters/database/Adapters/jsonServer/item.jsonServer.Adapter.ts
import { ItemData } from 'entities/item'

import { ItemAdapter } from '../adapterInterfaces'
import axios from './myAxios'

export const createItemAdapterJsonServer1 = (): ItemAdapter => {
  const getById = async (id: string): Promise<ItemData | undefined> => {
    const result = await axios.get<ItemData>(`/item/${id}`)
    return result
  }
  const getByOrderId = async (orderId: string): Promise<ItemData[]> => {
    const result =
      (await axios.get<ItemData[]>(`/item?orderId=${orderId}`)) ?? []
    return result
  }
  const getByOrderIds = async (orderIds: string[]): Promise<ItemData[]> => {
    const result =
      (await axios.get<ItemData[]>(
        `/item?orderId=${orderIds.join('&orderId=')}`
      )) ?? []
    return result
  }
  return {
    getById,
    getByOrderId,
    getByOrderIds,
  }
}

export const createItemAdapterJsonServer2 = (): ItemAdapter => {
  const getById = (id: string): Promise<ItemData | undefined> =>
    axios.get<ItemData>(`/item/${id}`)

  const getByOrderId = async (orderId: string): Promise<ItemData[]> =>
    axios
      .get<ItemData[]>(`/item?orderId=${orderId}`)
      .then((response) => response ?? [])

  const getByOrderIds = async (orderIds: string[]): Promise<ItemData[]> =>
    axios
      .get<ItemData[]>(`/item?orderId=${orderIds.join('&orderId=')}`)
      .then((response) => response ?? [])

  return {
    getById,
    getByOrderId,
    getByOrderIds,
  }
}

export { createItemAdapterJsonServer2 as createItemAdapterJsonServer }


--- File: api\adapters\database\jsonServer\createOrderAdapterJsonServer.spec.ts ---
import { inMemory } from 'mock/inMemory'

import { createOrderAdapterJsonServer } from './createOrderAdapterJsonServer'

let accountId: string

describe('createOrderAdapterJsonServer (real Axios)', () => {
  describe('for existing accountId', () => {
    beforeAll(() => {
      accountId = 'account0'
    })
    describe('getById', () => {
      it('should return order for order id for current account', async () => {
        const orderAdapter = createOrderAdapterJsonServer(accountId)
        const orderData = await orderAdapter.getById('order1')
        expect(orderData).toEqual(inMemory.order[1])
      })
      it('should return undefined for order id from other account', async () => {
        const orderAdapter = createOrderAdapterJsonServer(accountId)
        const orderData = await orderAdapter.getById('order2')
        expect(orderData).toEqual(undefined)
      })
      it('should return undefined for unknown order id', async () => {
        const orderAdapter = createOrderAdapterJsonServer(accountId)
        const orderData = await orderAdapter.getById('unknown')
        expect(orderData).toBeUndefined()
      })
    })
    describe('getAll', () => {
      it('should return all orderData for accountId', async () => {
        console.log('accountId', `/order?supplierId=${accountId}`)
        const orderAdapter = createOrderAdapterJsonServer(accountId)
        const orderData = await orderAdapter.getAll()
        expect(orderData).toEqual(inMemory.order.slice(0, 2))
      })
    })
  })
  describe('for inexistant accountId', () => {
    beforeAll(() => {
      accountId = 'account99'
    })
    describe('getById', () => {
      it('should return orderData for order id', async () => {
        const orderAdapter = createOrderAdapterJsonServer(accountId)
        const orderData = await orderAdapter.getById('order2')
        expect(orderData).toBeUndefined()
      })
    })
  })
})


--- File: api\adapters\database\jsonServer\createOrderAdapterJsonServer.ts ---
import { OrderData } from 'entities/order'

import { OrderAdapter } from '../adapterInterfaces'
import axios from './myAxios'

export const createOrderAdapterJsonServer = (
  accountId: string
): OrderAdapter => {
  const getAll = async (): Promise<OrderData[]> => {
    const clientOrders =
      (await axios.get<OrderData[]>(`/order?clientId=${accountId}`)) ?? []
    const supplierOrders =
      (await axios.get<OrderData[]>(`/order?supplierId=${accountId}`)) ?? []
    // console.log('clientOrders', clientOrders)
    // console.log('supplierOrders', supplierOrders)
    return [...clientOrders, ...supplierOrders]
  }
  const getById = async (orderId: string): Promise<OrderData | undefined> => {
    const result = (await getAll()) ?? []
    return result.find((order) => order.id === orderId)
  }
  return {
    getAll,
    getById,
  }
}


--- File: api\adapters\database\jsonServer\myAxios.ts ---
// src/adapters/database/Adapters/jsonServer/item.jsonServer.Adapter.ts
import axios, { AxiosResponse, Method } from 'axios'
export const myAxios = axios.create({
  baseURL: 'http://localhost:3057/',
  timeout: 1000,
})

export const handleRequest =
  (httpMethod: Method) =>
  async <Item>(url: string, data?: any): Promise<Item | undefined> => {
    try {
      const response: AxiosResponse = await myAxios.request({
        url,
        method: httpMethod,
        data,
      })
      return response.data
    } catch (error) {
      // console.error(error)
      return undefined
    }
  }

export default {
  get: handleRequest('get'),
  post: handleRequest('post'),
  delete: handleRequest('delete'),
  put: handleRequest('put'),
}


--- File: api\core\entities\item.ts ---
export interface ItemData {
  id: string
  orderId: string
  name: string
  quantity: number
  unit: string
  unitPriceExclTax: number
  taxRate: number
}

export interface Item extends ItemData {
  unitPriceInclTax: number
  amountExclTax: number
  amountInclTax: number
  taxAmount: number
}


--- File: api\core\entities\order.ts ---
import { Item } from './item'

// src / core / entities / order.ts
export interface OrderData {
  id: string
  clientId: string
  supplierId: string
  name?: string
  // Questions: Should we store it in the database ?
  principal?: number // principal is the amount including tax.
}

export interface Order extends OrderData {
  items: Item[]
  amountExclTax: number
  amountInclTax: number
  taxAmount: number
  averageTaxRate: number
}


--- File: api\core\gateways\gatewayInterfaces.ts ---
import { Item, ItemData } from 'entities/item'
import { Order, OrderData } from 'entities/order'

export interface ItemGateway {
  getAllData: () => ItemData[]
  getByIdData: (itemId: string) => ItemData | undefined
  getByOrderIdData: (orderId: string) => ItemData[]
  getAll: () => Item[]
  getById: (itemId: string) => Item | undefined
  getByOrderId: (orderId: string) => Item[]
}

export interface OrderGateway {
  getAllData: () => OrderData[]
  getByIdData: (orderId: string) => OrderData | undefined
  getAll: () => Order[]
  getById: (orderId: string) => Order | undefined
}


--- File: api\core\gateways\itemGateway.spec.ts ---
import { createItemGateway } from 'gateways/itemGateway'
import { itemDatas, items } from 'mock/inMemory'

import { createItemAdapterInMemory } from 'src/adapters/database/inMemory/createItemAdapterInMemory'

let itemAdapter: any
let itemGateway: any
describe('itemGateway', () => {
  beforeAll(() => {
    itemAdapter = createItemAdapterInMemory()
    itemGateway = createItemGateway(itemAdapter)
  })

  describe('getByIdData', () => {
    it('should return the item with raw data only', async () => {
      const result = await itemGateway.getByIdData('item0')
      expect(result).toEqual(itemDatas[0])
    })
  })

  describe('getByOrderIdData', () => {
    it('should return the items with raw data for the given order id', async () => {
      const result = await itemGateway.getByOrderIdData('order0')
      expect(result).toEqual(itemDatas.slice(0, 2))
    })
  })

  describe('getById', () => {
    it('should return the item with calculations', async () => {
      const result = await itemGateway.getById('item0')
      expect(result).toEqual(items[0])
    })
  })

  describe('getByOrderId', () => {
    it('should return the items with calculations for the given order id', async () => {
      const result = await itemGateway.getByOrderId('order0')
      expect(result).toEqual(items.slice(0, 2))
    })
  })
})


--- File: api\core\gateways\itemGateway.ts ---
import { Item, ItemData } from 'entities/item'
import { ItemAdapter } from 'src/adapters/database/adapterInterfaces'
import { round6 } from 'utils/round'

export const createItemGateway = (adapter: ItemAdapter) => {
  const getByIdData = async (itemId: string): Promise<ItemData | undefined> =>
    await adapter.getById(itemId)
  const getByOrderIdData = async (
    orderId: string
  ): Promise<ItemData[] | undefined> => await adapter.getByOrderId(orderId)
  const getById = async (itemId: string): Promise<Item | undefined> => {
    const item = await adapter.getById(itemId)
    return item !== undefined ? calculateItem(item) : undefined
  }
  const getByOrderId = async (orderId: string): Promise<Item[] | undefined> =>
    ((await adapter.getByOrderId(orderId)) ?? []).map(calculateItem)

  return {
    getByIdData,
    getByOrderIdData,
    getById,
    getByOrderId,
  }
}

function calculateItem(item: ItemData): Item {
  return {
    ...item,
    unitPriceInclTax: round6(item.unitPriceExclTax * (1 + item.taxRate)),
    amountExclTax: round6(item.quantity * item.unitPriceExclTax),
    taxAmount: round6(item.quantity * item.unitPriceExclTax * item.taxRate),
    amountInclTax: round6(
      item.quantity * item.unitPriceExclTax * (1 + item.taxRate)
    ),
  }
}


--- File: api\core\gateways\orderGateway.spec.ts ---
import { createOrderGateway } from 'gateways/orderGateway'
import { orderDatas, orders } from 'mock/inMemory'

import {
  ItemAdapter,
  OrderAdapter,
} from 'src/adapters/database/adapterInterfaces'
import { createItemAdapter } from 'src/adapters/database/index'
import { createOrderAdapter } from 'src/adapters/database/index'

import { OrderGateway } from './gatewayInterfaces'

let orderAdapter: OrderAdapter
let itemAdapter: ItemAdapter
let orderGateway: OrderGateway

describe('orderGateway', () => {
  describe('for existing account', () => {
    beforeEach(() => {
      orderAdapter = createOrderAdapter('account0')
      itemAdapter = createItemAdapter()
      orderGateway = createOrderGateway(orderAdapter, itemAdapter)
    })
    it('getByIdData should return the order with raw data only', async () => {
      const result = await orderGateway.getByIdData('order0')
      expect(result).toEqual(orderDatas[0])
    })
    it('getAllData should return all orders with items and calculations', async () => {
      const result = await orderGateway.getAllData()
      expect(result).toEqual(orderDatas.slice(0, 2))
    })
    it('getById should return the order with items and calculations', async () => {
      const result = await orderGateway.getById('order0')
      expect(result).toEqual(orders[0])
    })
    it('getAll should return all orders for this account', async () => {
      const result = await orderGateway.getAll()
      expect(result).toEqual(orders.slice(0, 2))
    })
  })

  describe('for inexisting account', () => {
    beforeEach(() => {
      orderAdapter = createOrderAdapter('account99')
      itemAdapter = createItemAdapter()
      orderGateway = createOrderGateway(orderAdapter, itemAdapter)
    })
    it('getByIdData should return undefined', async () => {
      const result = await orderGateway.getByIdData('order0')
      expect(result).toBeUndefined()
    })
    it('getAllData should return []', async () => {
      const result = await orderGateway.getAllData()
      expect(result).toEqual([])
    })
    it('getById should return undefined', async () => {
      const result = await orderGateway.getById('order0')
      expect(result).toBeUndefined()
    })
    it('getAll should return all []', async () => {
      const result = await orderGateway.getAll()
      expect(result).toEqual([])
    })
  })
})


--- File: api\core\gateways\orderGateway.ts ---
import { ItemAdapter, OrderAdapter } from 'adapters/database/adapterInterfaces'
import { Order, OrderData } from 'entities/order'
import { createItemGateway } from 'gateways/itemGateway'
import { round6 } from 'utils/round'

import { OrderGateway } from './gatewayInterfaces'

export const createOrderGateway = (
  orderAdapter: OrderAdapter,
  itemAdapter: ItemAdapter
): OrderGateway => {
  const itemGateway = createItemGateway(itemAdapter)
  const addItemsAndCalculate = async (order: OrderData): Promise<Order> => {
    const items = (await itemGateway.getByOrderId(order.id)) ?? []

    const amountExclTax = round6(
      items.reduce((sum, item) => sum + item.amountExclTax, 0)
    )
    const taxAmount = round6(
      items.reduce((sum, item) => sum + item.amountExclTax * item.taxRate, 0)
    )
    const amountInclTax = round6(amountExclTax + taxAmount)
    const averageTaxRate = amountExclTax ? round6(taxAmount / amountExclTax) : 0

    return {
      name: order.name ? order.name : '',
      ...order,
      items: items,
      amountExclTax,
      amountInclTax,
      taxAmount,
      averageTaxRate,
      principal: amountInclTax,
    }
  }
  const getAllData = async (): Promise<OrderData[]> =>
    await orderAdapter.getAll()
  const getByIdData = async (orderId: string): Promise<OrderData | undefined> =>
    await orderAdapter.getById(orderId)
  const getAll = async (): Promise<Order[]> => {
    const orderDatas = await orderAdapter.getAll()
    const orders = await Promise.all(orderDatas.map(addItemsAndCalculate))
    return orders
  }

  const getById = async (orderId: string): Promise<Order | undefined> => {
    const order = await orderAdapter.getById(orderId)
    if (order) {
      return addItemsAndCalculate(order)
    }
    return undefined
  }
  return {
    getAllData,
    getByIdData,
    getAll,
    getById,
  }
}


--- File: api\core\usecases\getAllAccounts.js ---
import axios from 'axios'

const DB_URL = 'http://localhost:3057/'
export default async () => {
  const accounts = await axios()
}


--- File: api\core\usecases\getAllOrdersForAccountId.spec.ts ---
import { orders } from 'mock/inMemory'

import { getAllOrdersForAccountId } from './getAllOrdersForAccountId'

describe('getAllOrdersForAccountId', () => {
  it.only('should return all orders for an existing account ID', async () => {
    const result = await getAllOrdersForAccountId('account0')
    expect(result).toEqual(orders.slice(0, 2))
  })

  it.only('should return empty array for inexistant id', async () => {
    const result = await getAllOrdersForAccountId('account99')
    expect(result).toEqual([])
  })
})


--- File: api\core\usecases\getAllOrdersForAccountId.ts ---
import { createItemAdapter, createOrderAdapter } from 'adapters/database/index'
import { config } from 'dotenv'
import { Order } from 'entities/order'
import { createOrderGateway } from 'gateways/orderGateway'
config() // load variables from .env into process.env

export const getAllOrdersForAccountId = async (
  accountId: string
): Promise<Order[]> => {
  console.log(
    'Core : getAllOrdersForAccountId → process.env.STORAGE_TYPE',
    process.env.STORAGE_TYPE
  )
  const orderGateway = createOrderGateway(
    createOrderAdapter(accountId),
    createItemAdapter()
  )
  const orders = await orderGateway.getAll()
  return orders
}


--- File: api\server\package.json ---
{
  "type": "module",
  "scripts": {
    "start": "tsx src/index.ts",
  },
  "dependencies": {
    "@hono/node-server": "^1.2.0",
    "hono": "^3.7.2"
  },
  "devDependencies": {
    "tsx": "^3.12.2"
  }
}

--- File: api\server\src\index.ts ---
import { serve } from '@hono/node-server'
// import { getAllOrdersForAccountId } from 'core/usecases/getAllOrdersForAccountId'
import { config } from 'dotenv'
import { Hono } from 'hono'
import { cors } from 'hono/cors'
config() // load variables from .env into process.env

const app = new Hono()
app.use('/order/:accountId', cors())
app.use('/db/:selectedDb', cors())
app.use(
  '/order/:accountId',
  cors({
    origin: '*',
    allowHeaders: ['Content-Type', 'Authorization', 'X-Custom-Header', 'Upgrade-Insecure-Requests'],
    allowMethods: ['POST', 'GET', 'OPTIONS'],
    exposeHeaders: ['Content-Length'],
    maxAge: 600,
    credentials: true
  })
)

// ROUTES
// app.post('/db/:selectedDb', async (c) => {
//   const selectedDb: string = c.req.param('selectedDb')
//   console.log('req path', c.req.path)
//   console.log('Hono: POST Request → selectedDb', selectedDb)
//   process.env.STORAGE_TYPE = selectedDb
//   console.log('Hono: process.env.STORAGE_TYPE', process.env.STORAGE_TYPE)
//   return c.text(selectedDb)
// })
//
// app.get('/order/:accountId', async (c) => {
//   const accountId = c.req.param('accountId')
//   console.log('req path', c.req.path)
//   console.log('Hono: process.env.STORAGE_TYPE', process.env.STORAGE_TYPE)
//   const orders = await getAllOrdersForAccountId(accountId)
//   // console.log('orders', JSON.stringify(orders, null, 2))
//   return c.json(orders)
// })

app.get('/fab', (c) => c.text('Hello Fabrizio!'))
app.get('/', (c) => c.text('Hello Hono Fab!'))
serve(app)


--- File: api\server\tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ESNext", "DOM"],
    "moduleResolution": "node",
    "strict": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "noEmit": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "skipLibCheck": true,
    "types": ["vitest/importMeta", "vitest/globals"],
    "baseUrl": ".",
    "paths": {
      "src/*": ["./src/*", "./src"],
      "core/*": ["./src/core/*", "./src/core"],
      "entities/*": ["./src/core/entities/*", "./src/core/entities"],
      "usecases/*": ["./src/core/usecases/*", "./src/core/usecases"],
      "gateways/*": ["./src/core/gateways/*", "./src/core/gateways"],
      "adapters/*": ["./src/adapters/*", "./src/adapters"],
      "utils/*": ["./src/utils/*", "./src/utils"],
      "mock/*": ["./mock/*", "./mock"]
    }
  },
  "include": ["src/**/*", "mock/**/*"],
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  }
}


--- File: api\utils\add.test.ts ---
import add from './add'

describe('sample add test suite', () => {
  it('should add two numbers', () => {
    const assertion = add(1, 2)
    const result = 3
    expect(assertion).toEqual(result)
  })
})


--- File: api\utils\add.ts ---
export default (x: number, y: number): number => x + y


--- File: api\utils\round.ts ---
export const round6 = (value: number): number => {
  return value ? Math.round(value * 1000000) / 1000000 : 0
}


--- File: app\app.vue ---
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>


--- File: app\assets\css\tailwind.css ---
/* explain what each line does */
@import 'tailwindcss/base'; /* imports the base styles */
@import 'tailwindcss/components'; /* imports the component styles */
@import 'tailwindcss/utilities'; /* imports the utility styles */

body {
  font-family: 'Open Sans', sans-serif;
}

h1 {
  @apply mt-3 text-6xl font-bold;
}

h2 {
  @apply mt-3 text-4xl font-semibold;
}

h3 {
  @apply mt-3 text-2xl font-semibold;
}

html {
  @apply h-full bg-white;
}

body {
  @apply h-full;
}

main {
  @apply m-5 h-full;
}


--- File: app\composables\fetchOrders.spec.ts ---
// import { fetchOrders } from './fetchOrders'

describe('fetchOrders', () => {
  it('should return an array of orders for existing account ID', async () => {
    // const accountId = 'account0'
    // const orders = await fetchOrders(accountId)
    // expect(orders).toEqual([])
    expect(true).toBe(true)
  })
})


--- File: app\composables\fetchOrders.ts ---
import axios from 'axios'

export const fetchOrders = async (accountId: string) => {
  try {
    const response = await axios.get(`http://localhost:3000/order/${accountId}`)
    console.log('Vue → fetchOrders:', response.data)
    return response.data
  } catch (error) {
    console.error(error)
  }
}


--- File: app\composables\getAccounts.js ---
export const accountList = [
  {
    id: 1,
    name: 'FlexUp',
    type: 'Activity',
    icon: '@/assets/images/profiles/flexup-icon.svg'
  },
  {
    id: 2,
    name: "Pizza d'Oro",
    type: 'Business',
    icon: '@/assets/images/profiles/pizza_d_oro.png'
  },
  {
    id: 3,
    name: 'Fabrizio Nastri',
    type: 'Personal',
    icon: '@/assets/images/profiles/fabrizio_nastri.jpeg'
  },
  {
    id: 4,
    name: 'Frédéric Lasnier',
    type: 'Personal',
    icon: '@/assets/images/profiles/fred.png'
  }
]

export const getAccounts = () => accountList

export default getAccounts


--- File: app\composables\getAccounts.test.js ---
import { getAccounts, accountList } from './getAccounts.js'

describe('getAccounts', () => {
  it('should return accounts list', () => {
    const assertion = getAccounts()
    const result = accountList
    expect(assertion).toEqual(result)
  })
})


--- File: app\composables\selectDb.ts ---
import axios from 'axios'

export const selectDb = async (selectedDb: string) => {
  try {
    const response = await axios.post(`http://localhost:3000/db/${selectedDb}`)
    console.log('Vue → selectedDb function:', response)
    return response.data
  } catch (error) {
    console.error(error)
  }
}


--- File: app\composables\sharedState.ts ---
import { reactive } from 'vue'

export const sharedState = reactive({
  selectedAccountId: 'account0', // Default value
})


--- File: app\error.vue ---
<script setup>
  const error = useError()
  const handleError = () => {
    clearError({
      redirect: '/'
    })
  }
</script>

<template>
  <div class="flex h-screen flex-col items-center justify-center gap-7 leading-loose">
    <h1 class="text-8xl font-bold">Fabri Error</h1>
    <h2 class="p-5 px-20 text-6xl font-bold">
      {{ error?.statusCode }}
    </h2>
    <p>{{ error?.message }}</p>
    <v-btn color="primary" @click="handleError"> Go back </v-btn>
  </div>
</template>


--- File: app\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>Hello</h1>
  <img src="./app/assets/images/profiles/fabrizio_nastri.jpeg"/>

</body>
</html>

--- File: app\layouts\default.vue ---
<template lang="pug">
div
  NavBar
  main
    slot
</template>

<script setup></script>


--- File: app\pages\index.vue ---
<template lang="pug">
div
  h1.mt-10 FlexUp MVP
  //- People
  //- SelectAccount
  img(src="../app/assets/images/profiles/fabrizio_nastri.jpeg")

</template>

<script setup></script>


--- File: app\pages\Mini.vue ---
<script setup lang="ts">
import NavBar from './components/NavBar.vue'
import OrderList from './components/OrderList.vue'
</script>

<template>
  <main>
    <NavBar />
    <OrderList />
  </main>
</template>

<style>
body {
  font-family: 'Open Sans', sans-serif;
}
select {
  font-size: large;
  padding: 3px 6px;
  line-height: 2em;
}
</style>


--- File: app\pages\teams.vue ---
<template>
  <h1>Teams</h1>
  <TeamList :teams="teams" />
</template>

<script setup>
  const teams = [
    {
      id: 1,
      name: 'Toronto Maple Leafs',
      city: 'Toronto',
      logo: 'https://upload.wikimedia.org/wikipedia/en/thumb/b/b6/Toronto_Maple_Leafs_2016_logo.svg/1200px-Toronto_Maple_Leafs_2016_logo.svg.png'
    }
  ]
</script>


--- File: nodemon.json ---
{
  "watch": [
    "src/adapters/backend/hono/src/*"
  ],
  "ext": "ts, json",
  "ignore": [
    "src/**/*.spec.ts"
  ],
  "exec": "tsx api/server/src/index.ts"
}

--- File: nuxt.config.ts ---
// https://nuxt.com/docs/api/configuration/nuxt-config

export default defineNuxtConfig({
  // devServer: {
  //   host: '0.0.0.0', // Listen to all network interfaces
  //   port: 3000 // Default port is 3000
  // },
  srcDir: 'app',
  devtools: { enabled: true },
  modules: ['@nuxtjs/tailwindcss', '@nuxtjs/eslint-module', 'nuxt-vitest'],
  plugins: [
    //
  ],
  imports: {
    dirs: ['composables/**', '../utils/**']
  },
  // css: ['@/assets/main.css'], // removed, use tailwind instead
  vite: {
    define: {
      'process.env.DEBUG': false
    }
  }
})


--- File: package.json ---
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "format": "prettier --write .",
    "generate": "nuxt generate",
    "lint": "eslint --ext .js,.vue --ignore-path .gitignore .",
    "postinstall": "nuxt prepare",
    "preview": "nuxt preview",
    "test:cov": "vitest --reporter verbose --coverage",
    "test": "vitest --reporter verbose",
    "server": "nodemon",
    "db": " json-server --port 3057 --watch ./db/db.json"
  },
  "devDependencies": {
    "@headlessui/vue": "^1.7.16",
    "@heroicons/vue": "^2.0.18",
    "@nuxt/devtools": "latest",
    "@nuxtjs/eslint-module": "^4.1.0",
    "@nuxtjs/tailwindcss": "^6.8.0",
    "@types/node": "^20.8.2",
    "@vue/eslint-config-prettier": "^8.0.0",
    "@vue/eslint-config-typescript": "^12.0.0",
    "@vue/language-plugin-pug": "^1.8.15",
    "eslint": "^8.50.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-vitest-globals": "^1.4.0",
    "happy-dom": "11.0.0",
    "nuxt": "^3.7.4",
    "nuxt-vitest": "^0.11.0",
    "prettier": "^3.0.3",
    "prettier-plugin-tailwindcss": "^0.5.5",
    "pug": "^3.0.2",
    "ts-node": "^10.9.1",
    "tsx": "^3.13.0",
    "typescript": "^5.2.2",
    "vitest": "^0.33.0"
  },
  "dependencies": {
    "@hono/node-server": "^1.2.0",
    "@mdi/font": "^7.2.96",
    "@tailwindcss/forms": "^0.5.6",
    "@typescript-eslint/eslint-plugin": "^6.7.4",
    "@typescript-eslint/parser": "^6.7.4",
    "axios": "^1.5.1",
    "eslint-plugin-vue": "^9.17.0",
    "hono": "^3.7.5"
  }
}

--- File: prettier.config.js ---
// prettier.config.js
module.exports = {
  plugins: ['prettier-plugin-tailwindcss']
}


--- File: tailwind.config.js ---
/** @type {import('tailwindcss').Config} */

import defaultTheme from 'tailwindcss/defaultTheme' // import the default theme from the tailwind library
// checkout the list found here: .\node_modules\tailwindcss\stubs\config.full.js
// or here: https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/config.full.js#L301

export default {
  content: ['./index.html', './src/**/*.{js,vue}'],
  theme: {
    extend: {
      fontFamily: {
        // we don't want to only offer Open Sans, but add it to the default fonts as the first option
        // if the font is not available, the browser will use the next font in the list
        sans: ['Inter var', 'Open Sans', ...defaultTheme.fontFamily.sans] // this is how we can add a new font to our project
      },
      colors: {
        primary: '#328de7'
        // this is how we can add a new color to our project
        // 'brand-gray-1': '#dadce0', // were using "" because the color name has a dash in it, and JavaScript doesn't support dashes in property names
        // 'brand-gray-2': '#f8f9fa',
        // 'brand-gray-3': '#80868b',
        // 'brand-blue-1': '#1967d2',
        // 'brand-blue-2': '#4285f4',
        // 'brand-green-1': '#137333'
      },
      boxShadow: {
        // blue: '0 0 3px 3px #4285f4', // use this with shadow-blue
        // gray: '0 1px 3px 0 rgba(60, 64, 67, 0.3)' // use this with shadow-gray
      }
    }
  },
  plugins: [require('@tailwindcss/forms')]
}


--- File: tsconfig.json ---
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./*"],
      "@/*": ["./app/*"],
      "api/*": ["./api/*"],
      "app/*": ["./app/*"],
      "src/*": ["./api/*", "./api"],
      "core/*": ["./api/core/*", "./api/core"],
      "entities/*": ["./api/core/entities/*", "./api/core/entities"],
      "usecases/*": ["./api/core/usecases/*", "./api/core/usecases"],
      "gateways/*": ["./api/core/gateways/*", "./api/core/gateways"],
      "adapters/*": ["./api/adapters/*", "./api/adapters"],
      "utils/*": ["./api/utils/*", "./api/utils"],
      "mock/*": ["./mock/*", "./mock"]
    },
    "include": ["api/**/*", "mock/**/*"],
    "ts-node": {
      "esm": true,
      "experimentalSpecifierResolution": "node"
    },
    "types": ["vitest/globals"] // to avoid linting error
  }
  // "vueCompilerOptions": {
  //   "plugins": ["@vue/language-plugin-pug"] // PUG does not work
  // }
}


--- File: vitest.config.ts ---
import { defineVitestConfig } from 'nuxt-vitest/config'
import path from 'path'

export default defineVitestConfig({
  // plugins: path.resolve(__dirname,  vue()  ],
  test: {
    environment: 'nuxt',
    globals: true,
    includeSource: ['api/**/*.{js,ts}', 'app/**/*.{js,ts,vue}']
  },
  resolve: {
    alias: {
      '~': path.resolve(__dirname, './'),
      '@': path.resolve(__dirname, './app'),
      mocks: path.resolve(__dirname, './__mocks__'),
      utils: path.resolve(__dirname, './utils'),
      app: path.resolve(__dirname, './app'),
      api: path.resolve(__dirname, './api'),
      server: path.resolve(__dirname, './app/server'),
      components: path.resolve(__dirname, './app/components'),
      layouts: path.resolve(__dirname, './app/layouts'),
      pages: path.resolve(__dirname, './app/pages'),
      composables: path.resolve(__dirname, './app/composables'),
      '~/*': path.resolve(__dirname, './*'),
      '@/*': path.resolve(__dirname, './app/*'),
      'api/*': path.resolve(__dirname, './api/*'),
      'app/*': path.resolve(__dirname, './app/*'),
      'src/*': path.resolve(__dirname, './api/*', './api'),
      'core/*': path.resolve(__dirname, './api/core/*', './api/core'),
      'entities/*': path.resolve(__dirname, './api/core/entities/*', './api/core/entities'),
      'usecases/*': path.resolve(__dirname, './api/core/usecases/*', './api/core/usecases'),
      'gateways/*': path.resolve(__dirname, './api/core/gateways/*', './api/core/gateways'),
      'adapters/*': path.resolve(__dirname, './api/adapters/*', './api/adapters'),
      'utils/*': path.resolve(__dirname, './api/utils/*', './api/utils'),
      'mock/*': path.resolve(__dirname, './mock/*', './mock')
    }
  }
})

